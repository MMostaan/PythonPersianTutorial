.. role:: emoji-size

.. meta::
  :description: پایتون به پارسی - کتاب آنلاین و آزاد آموزش زبان برنامه‌نویسی پایتون - درس هفتم: انواع داده در پایتون، عددی
  :keywords: آموزش انواع عددی در پایتون، اعداد صحیح (integer) در پایتون، ممیز شناور float و double در پایتون، آموزش اعداد مختلط در پایتون (Complex Numbers)، نوع بولین bool یا boolean در پایتون، آموزش نوع داده کسر (fractions) در پایتون، آموزش نوع داده دسیمال (decimal) در پایتون، ب م م در پایتون


.. _lesson-07.1: 

درس ۰۷: انواع داده در پایتون: عددی
===========================================================

.. figure:: /_static/pages/07-python-built-in-data-types-0.jpg
    :align: center
    :alt: انواع داده در پایتون: عددی
    :class: page-image

    Photo by `Mick Haupt <https://unsplash.com/photos/ePHz9WOME0c>`__


پایتون هر «نوع داده» (Data Type) را توسط یک کلاس ارایه می‌دهد؛ بنابراین هر داده یک نمونه یا یک شی از کلاسی مشخص است. هر چند برنامه‌نویس نیز می‌تواند با تعریف کلاس، نوع دلخواه خود را داشته باشد ولی در این درس می‌خواهیم درباره آن بخشی از انواع داده یا انواع شی‌ای که به شکل آماده (Built-in) در اختیار مفسر زبان پایتون قرار داده شده است صحبت کنیم. 

در این بخش از درس هفتم تنها به بررسی «انواع شی عددی» در پایتون پرداخته می‌شود و انواع باقی مانده دیگر توسط بخش‌های بعدی بررسی خواهند شد. 

با اینکه تلاش شده است جزییات کامل باشند ولی در برخی بخش‌ها مطالعه اسناد رسمی پایتون می‌تواند اطلاعات کامل‌تری را در اختیار شما قرار دهد. در مواقع بسیاری از تابع‌های آماده پایتون استفاده خواهد شد که ممکن است جزییاتی بیشتر از آنچه در این درس بیان می‌شود را داشته باشند؛ به همین دلیل لینک تعریف آن‌ها در اسناد پایتون نیز ارایه گشته است. نکته مهم در مطالعه این درس بررسی نمونه کدهاست که گاهی درک توضیحی که داده شده است بدون دقت در این نمونه کدها ناممکن خواهد بود.


:emoji-size:`✔` سطح: مقدماتی

----

.. contents:: سرفصل‌ها
    :depth: 3

----


.. _python-numeric-types: 

انواع عددی
---------------


در زبان پایتون دسته‌ای از انواع شی وجود دارد که برای کار با داده‌های عددی ایجاد گشته‌اند؛ از این جهت به عنوان «انواع عددی» (Numeric Types) شناخته می‌شوند. این انواع شی عبارتند از:

* صحیح (Integer)
* ممیز شناور (Floating-Point)
* مختلط (Complex)
* دسیمال (Decimal)
* کسر (Fraction)
* بولی (Boolean)

*در ادامه به بررسی هر یک خواهیم پرداخت.*


.. _python-integer-numbers: 

صحیح (Integer)
---------------------


این نوع از اشیا تمام اعداد مثبت و منفی بدون «ممیز اعشار» را شامل می‌شوند؛ مانند: ``1234``، ``26-`` و...

از نسخه 3.0 پایتون اعداد صحیح تنها در قالب یک نوع ``int`` (بدون محدودیت اندازه) ارایه می‌گردد و::


    >>> type(-3)
    <class 'int'>

    >>> a = 3
    >>> type(a)
    <class 'int'>

اکنون در پایتون هیچ محدودیتی برای طول اعداد صحیح وجود ندارد، اما در صورت نیاز می‌توان با استفاده از ``sys.maxsize``، مقدار مرسوم برای بیشینه مقدار این دست از اعداد را به دست آورد::

    >>> import sys

    >>> sys.maxsize
    9223372036854775807
    >>> type(_)
    <class 'int'>

    >>> type(sys.maxsize + 1)
    <class 'int'>


.. note::
    منظور از اندازه نامحدود اعداد این است که اندازه این اشیا تنها محدود به میزان حافظه‌ (Memory) آزاد بوده و تا هر اندازه‌ای که حافظه در دسترس باشد می‌توانند در محاسبات رشد داشته باشند.

اعداد صحیح را می‌توان علاوه بر پایه ده؛ در پایه دو (Binary)، پایه هشت (Octal) و پایه شانزده (Hexadecimal) نیز در نظر گرفت. به این صورت که:

* **اعداد پایه دو** می‌بایست با یک ``0b`` یا ``0B`` (صفر و حرف بی کوچک یا بزرگ) آغاز گردند؛ مانند: ``0b11`` که برابر عدد ``3`` در پایه ده است::

    >>> a = 0b11
    >>> type(a)
    <class 'int'>
    >>> a
    3


* **اعداد پایه هشت** می‌بایست با یک ``0o`` یا ``0O`` (صفر و حرف اُ کوچک یا بزرگ) آغاز گردند؛ مانند: ``0o14`` که برابر عدد ``12`` در پایه ده است::

    >>> a = 0o14
    >>> type(a)
    <class 'int'>
    >>> a
    12

* **اعداد پایه شانزده** می‌بایست با یک ``0x`` یا ``0X`` (صفر و حرف اِکس کوچک یا بزرگ) آغاز گردند؛ مانند: ``0xA5`` که برابر عدد ``165`` در پایه ده است::

    >>> a = 0xA5
    >>> type(a)
    <class 'int'>
    >>> a
    165
    >>> print(a)
    165

همانطور که در نمونه کدهای بالا نیز قابل مشاهده است؛ نوع شی صحیح در پایه‌های گوناگون تفاوتی ندارند (همان ``int`` است) و در پایتون تنها از یک سینتکس متفاوت برای مشخص کردن آن‌ها استفاده شده است. همچنین در هنگام وارد کردن این اشیا در حالت تعاملی یا استفاده از تابع ``print``، این اشیا در پایه ده نمایش داده می‌شوند.


برای تبدیل یک عدد صحیح از پایه ده به هر یک از این پایه‌ها می‌توانید از تابع‌های آماده ``()bin`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#bin>`__] برای تبدیل به پایه دو، ``()oct`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#oct>`__] برای تبدیل به پایه هشت و ``()hex`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#hex>`__] برای تبدیل به پایه شانزده استفاده نمایید. تنها توجه داشته باشید که خروجی هر یک از این تابع‌ها به صورت یک شی از نوع رشته یا String برگردانده می‌شود و نه یک نوع عددی::

    >>> a = 3
    >>> b = bin(a)
    >>> b
    '0b11'
    >>> type(b)
    <class 'str'>

    >>> a = 12
    >>> b = oct(a)
    >>> b
    '0o14'
    >>> type(b)
    <class 'str'>

    >>> a = 165
    >>> b = hex(a)
    >>> b
    '0xa5'
    >>> type(b)
    <class 'str'>

و برای برگرداندن پایه اعداد صحیح به پایه ده می‌توان از کلاس ``()int`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#int>`__] استفاده کرد. آرگومان‌های نمونه این کلاس به صورت ``(int(str, base`` می‌باشد؛ آرگومان یکم: str می‌بایست یک «رشته عددی» یعنی یک عدد صحیح (در هر پایه‌ای) داخل نمادهای نقل قول (Quotation) باشد که آرگومان دوم، پایه (Base) آن را مشخص می‌کند. در نهایت این کلاس یک شی ``int`` متناظر با آرگومان یکم ولی در پایه ده را برمی‌گرداند::

    >>> a = 165

    >>> type(a)
    <class 'int'>

    >>> b = hex(a)          # Converted to hexadecimal
    >>> b
    '0xa5'

    >>> type(b)
    <class 'str'>

    >>> int(b, 16)           # str='0xa5' base=16
    165

    >>> type(int(b, 16))
    <class 'int'>



توجه داشته باشید که می‌توان اعداد را بدون حرف مشخص کننده پایه (``0x`` ``0o`` ``0b``) به این کلاس ارسال کنیم. همچنین از این کلاس می‌توان برای تبدیل **نوع** رشته‌های عددی در پایه ده به **عدد صحیح** استفاده کرد. مقدار پیش‌فرض آرگومان پایه ``10`` است؛ بنابراین در هنگام ارسال یک رشته عددی در این پایه، نیازی به ذکر پایه ``10`` نمی‌باشد::


    >>> int("A5", 16)    # 0xA5
    165

::

    >>> a = "56"

    >>> type(a)
    <class 'str'>

    >>> int(a, 10)
    56
    >>> int(a)
    56

    >>> type(int(a))
    <class 'int'>

::

    >>> int()
    0

*()int بدون آرگومان یک شی صفر از نوع صحیح را برمی‌گرداند.*

.. note::
    منظور از «رشته عددی»، رشته‌ای است که به گونه‌ای بتوان آن را به یک عدد ارزیابی نمود. مانند: ``"25"``، ``"0x2F"`` و... که بدیهی است قرار دادن رشته‌هایی همچون ``"0w55"`` و... - که به هیچ شکلی نمی‌توان آن‌ها را به عددی در پایتون ارزیابی نمود - در آرگومان ``()int`` موجب بروز خطا می‌گردد.


همچنین برای به دست آوردن اندازه یا میزان حافظه گرفته شده توسط یک شی به واحد بایت (Byte) می‌توان از تابع ``()getsizeof`` [`اسناد پایتون  <https://docs.python.org/3/library/sys.html#sys.getsizeof>`__] درون ماژول ``sys`` استفاده نماییم - خروجی این تابع  برای دو شی صحیح دلخواه در یک نمونه کامپیوتر ۶۴ بیتی به صورت پایین است::

    >>> import sys

    >>> a = 1
    >>> sys.getsizeof(a)
    28
    >>> sys.getsizeof(10**100)
    72

    >>> s = "1"
    >>> sys.getsizeof(s)
    50


.. admonition:: تمرین
    
    برنامه‌ای بنویسید که حاصل جمع  تمام اعداد صحیح از یک تا 100 را محاسبه و در قالب یک عدد صحیح در خروجی نمایش دهد.
       

    ** `راهنمای ریاضی  <https://www.cuemath.com/sum-of-natural-numbers-formula/>`__


.. _python-float-numbers: 

ممیز شناور (float)
----------------------

تمام اعداد مثبت و منفی که شامل یک «ممیز اعشار» هستند در پایتون به صورت اشیایی با نوع ``float`` (معادل نوع ``double`` در زبان C) ارایه می‌شوند؛ مانند: ``3.1415``، ``.5`` (برابر ``5.0``) و... ::

    >>> a = 3.1415
    >>> type(a)
    <class 'float'>

    >>> import sys
    >>> sys.getsizeof(a)
    24

جزییات این نوع با استفاده از ``sys.float_info`` [`اسناد پایتون  <https://docs.python.org/3/library/sys.html#sys.float_info>`__] قابل مشاهده است::

    >>> import sys
    >>> sys.float_info
    sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)

گاهی برای نمایش اعداد از شیوه «نماد علمی» (`Scientific Notation <https://en.wikipedia.org/wiki/Scientific_notation>`_) استفاده می‌شود؛ در پایتون هم می‌توان از حرف ``E`` یا ``e`` که معادل «ضرب در ۱۰ به توانِ» می‌باشد، برای این منظور استفاده کرد.

.. raw:: html

    <div style="text-align:justify;margin-bottom:24px">برای نمونه: عبارت <code class="docutils literal"><span dir="ltr">4 × 10<sup>5</sup></span></code>، به شکل <code class="docutils literal">4E5</code> یا <code class="docutils literal">4e5</code> بیان می‌شود. پایتون این نوع اعداد را نیز در قالب اعداد ممیز شناور (اشیایی از نوع <code class="docutils literal">float</code>) ارايه می‌دهد:</div>

::

    >>> 3e2
    300.0

    >>> type(3e2)
    <class 'float'>

    >>> 3e-2
    0.03

    >>> 3e+2
    300.0

می‌توان از کلاس ``()float`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#float>`__] برای تبدیل اعداد یا رشته‌های عددی به یک شی ممیز شناور استفاده کرد::

    >>> a = 920

    >>> type(a)
    <class 'int'>

    >>> float(a)
    920.0

    >>> type(float(a))
    <class 'float'>

    >>> float("920")
    920.0

    >>> float("3e+2")
    300.0

::

    >>> float()
    0.0

*()float بدون آرگومان یک شی صفر از نوع ممیز شناور را برمی‌گرداند.*

چنانچه عددی از نوع ممیز شناور در آرگومان کلاس ``()int`` قرار بگیرد؛ تنها بخش صحیح عدد برگردانده می‌شود::

    >>> a = 2.31
    >>> type(a)
    <class 'float'>

    >>> int(a)
    2
    >>> type(int(a))
    <class 'int'>

    >>> int(3.9)
    3

با استفاده از کلاس ``()float`` می‌توانیم اشیایی با مقدارهای مثبت و منفی «بی‌نهایت» (infinity) برابر: ``inf`` یا ``infinity`` و «تعریف نشده» (Not a Number) برابر: ``NaN`` ایجاد نماییم - چگونگی کوچک یا بزرگ نوشتن حروف این کلمه‌ها تفاوتی در آن‌ها ایجاد نمی‌کند::

    >>> a = float('infinity')
    >>> a = float('inf')
    >>> a
    inf

    >>> b = float('-infinity')
    >>> b = float('-inf')
    >>> b
    -inf

    >>> c = float('NaN')
    >>> c
    nan

::

    >>> a = float('inf')

    >>> 5 / a
    0.0

    >>> a / a
    nan

::

    >>> a = float('inf')
    >>> b = float('inf')
    >>> a == b
    True

    >>> a = float('nan')
    >>> b = float('nan')
    >>> a == b
    False

*دو شی NaN با یکدیگر برابر نیستند.*

برای بررسی اینکه مقدار یک شی «بی‌نهایت» یا «تعریف نشده» است؛ می‌توان به ترتیب از تابع‌های ``()isinf`` [`اسناد پایتون  <https://docs.python.org/3/library/math.html#math.isinf>`__] و ``()isnan`` [`اسناد پایتون  <https://docs.python.org/3/library/math.html#math.isnan>`__] درون ماژول ``math`` استفاده نماییم::

    >>> a = float('inf')
    >>> b = float('nan')

    >>> import math

    >>> math.isinf(a)
    True
    >>> math.isnan(b)
    True


.. _python-complex-numbers: 

مختلط (Complex)
---------------------

همانطور که می‌دانیم اعداد مختلط (`Complex Numbers <https://en.wikipedia.org/wiki/Complex_number>`_) از یک بخش حقیقی (Real) و یک بخش موهومی (Imaginary) تشکیل شده‌اند. این اعداد در پایتون الگویی برابر ``RealPart + ImaginaryPart j`` دارند که حرف ``j`` نشانگر «واحد موهومی» است. این اعداد در پایتون توسط اشیایی با نوع ``complex`` ارایه می‌شوند::

    >>> a = 3 + 4j
    >>> type(a)
    <class 'complex'>

    >>> import sys
    >>> sys.getsizeof(a)
    32


از کلاس ``()complex`` [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#complex>`__] می‌توان برای ایجاد یک شی ``complex`` استفاده کرد. این کلاس الگویی مشابه ``(complex(real, imag`` دارد؛ آرگومان‌های نمونه real و imag بیانگر اعدادی هستند که به ترتیب قرار است در بخش‌های حقیقی و موهومی عدد مختلط مورد نظر وجود داشته باشند. اگر هر کدام از آرگومان‌ها ارسال نگردند به صورت پیش‌فرض صفر در نظر گرفته خواهند شد::

    >>> a = 3
    >>> b = 4

    >>> type(a)
    <class 'int'>
    >>> type(b)
    <class 'int'>

    >>> complex(a, b)
    (3+4j)

    >>> type(complex(a, b))
    <class 'complex'>

::

    >>> complex(3, 4)
    (3+4j)

    >>> complex(3)
    (3+0j)

    >>> complex(0, 4)
    4j

    >>> complex(4j)
    4j

::

    >>> a = 3 + 4j
    >>> a
    (3+4j)

    >>> a = 3.2 + 4j
    >>> a
    (3.2+4j)

    >>> a = 3.0 + 4j
    >>> a
    (3+4j)

    >>> a = 3.0 + 4.0j
    >>> a
    (3+4j)

همچنین با استفاده از دو صفت ``real`` و ``imag`` می‌توان بخش‌های حقیقی و موهومی هر شی ``complex`` را به دست آورد. توجه داشته باشید که جدا از این که اعداد از چه نوعی در تشکیل یک نوع مختلط شرکت کرده باشند؛ بخش‌های عدد مختلط به صورت عدد ممیز شناور تفکیک می‌گردند::

    >>> a = 3 + 4j

    >>> a.real
    3.0
    >>> a.imag
    4.0

``()complex`` توانایی دریافت یک رشته عددی و تبدیل آن به عدد مختلط را نیز دارد. تنها باید توجه داشت که نباید داخل این رشته هیچ فضای خالی وجود داشته باشد::

    >>> a = "3+4j"

    >>> type(a)
    <class 'str'>

    >>> complex(a)
    (3+4j)

    >>> a = "3"
    >>> complex(a)
    (3+0j)

    >>> type(complex(a))
    <class 'complex'>

::

    >>> a = "3 + 4j"
    >>> complex(a)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ValueError: complex() arg is a malformed string
    >>> 

.. note::
    امکان قرار دادن رشته عددی (مختلط) یا خود شی عدد مختلط در آرگومان کلاس‌های ``()int`` و ``()float`` وجود ندارد و موجب بروز خطا می‌شود.

.. _python-decimal-numbers: 

دسیمال (Decimal)
-----------------------

اساس طراحی این نوع برای استفاده در مواقعی است که خطا نوع ممیز شناور قابل گذشت نیست [`PEP 327 <https://www.python.org/dev/peps/pep-0327>`_] مانند توسعه برنامه حسابداری. 

در علوم کامپیوتر برای ارایه نوع ممیز شناور به کامپیوتر از کدگذاری Binary Floating-Point (`استاندارد IEEE 754 <https://en.wikipedia.org/wiki/IEEE_floating_point>`_) استفاده می‌شود. این کدگذاری اعداد را به شکل دقیق ارایه نمی‌دهد؛ به عنوان نمونه عدد  ``0.1`` برابر با عددی نزدیک به ``0.10000000000000001`` در محاسبات کامپیوتر شرکت داده می‌شود؛ هر چند که این عدد بسیار نزدیک به ``0.1`` است ولی به هر حال خود آن نیست!. این موضوع ممکن است در برخی موارد موجب خطا منطقی در برنامه گردد::

    >>> a = 0.1 + 0.1 + 0.1
    >>> a == 0.3
    False
    >>> a
    0.30000000000000004


*در نمونه کد بالا کاربر انتظار دارد که عبارت سطر دوم با ارزش درستی True ارزیابی گردد که این اتفاق نمی‌افتد.*

در پایتون نوع دسیمال  با ایجاد شی از کلاس  ``Decimal`` درون  ماژول ``decimal`` در دسترس خواهد بود [`اسناد پایتون  <https://docs.python.org/3/library/decimal.html>`__]. به نمونه کد پایین توجه نمایید::


    >>> from decimal import Decimal

    >>> a = Decimal('0.1')
    >>> a
    Decimal('0.1')

::

    >>> import decimal

    >>> a = decimal.Decimal('0.1')
    >>> b = decimal.Decimal('0.3')
    
    >>> b == a + a + a
    True

    >>> type(a)
    <class 'decimal.Decimal'>

    >>> a
    Decimal('0.1')

    >>> print(a)
    0.1

    >>> import sys
    >>> sys.getsizeof(a)
    104


به شیوه‌های گوناگونی می‌توان شی دسیمال ایجاد کرد:

.. code-block:: python
    :linenos:

    a = Decimal(23)                  # Creates Decimal("23")
    b = Decimal("23.45")             # Creates Decimal("23.45")
    c = Decimal("2345e-2")           # Creates Decimal("23.45")
    d = Decimal((1,(2,3,4,5),-2))    # Creates Decimal("-23.45")
    e = Decimal("infinity")
    f = Decimal("NaN")

* از آنجا که نوع ممیز شناور دقیق نیست؛ این اعداد را حتما به صورت رشته به ``Decimal`` ارسال نمایید (سطر دوم).
* اعداد را می‌توان به صورت یک شی توپِل (Tuple) - ساختاری مشابه: (... ,Ο, Ο, Ο) - ارسال کرد (سطر چهارم). شیوه نماد علمی را به یاد بیاورید؛ توپِل مورد نظر باید ساختاری مشابه الگو ``(sign, digits, exponent)`` داشته باشد که در آن sign مثبت بودن (توسط عدد صفر) یا منفی بودن (توسط عدد یک) را مشخص می‌کند، digits خود توپِلی است که رقم‌های دخیل را بیان می‌کند و exponent نیز بیانگر همان توان است.

میزان دقت (Precision) و عمل گرد کردن (Rounding) اعداد از نوع دسیمال با استفاده از یک شی ``Context`` قابل کنترل است؛ این شی یک سری اطلاعات پیکربندی را در اختیار اشیا دسیمال قرار می‌دهد که برای دسترسی به آن باید از  تابع ``()getcontext`` [`اسناد پایتون  <https://docs.python.org/3/library/decimal.html#decimal.getcontext>`__] درون ماژول ``decimal`` استفاده کرد. تابع ``()getcontext`` شی ``Context`` اشیا دسیمال جاری برنامه را برمی‌گرداند::

    >>> import decimal

    >>> a = decimal.Decimal('3.45623')
    >>> b = decimal.Decimal('0.12')

    >>> a + b
    Decimal('3.57623')

    >>> print(a + b)
    3.57623

    >>> ctx = decimal.getcontext()
    >>> type(ctx)
    <class 'decimal.Context'>

    >>> ctx.prec = 1
    >>> a + b
    Decimal('4')

    >>> ctx.prec = 2
    >>> a + b
    Decimal('3.6')

    >>> ctx.prec = 3
    >>> a + b
    Decimal('3.58')


همانطور که در نمونه کد بالا مشاهده می‌شود دقت محاسبات اعداد دسیمال را می‌توان با استفاده از صفت ``prec`` شی ``Context`` به شکل دلخواه تنظیم نمود؛ مقدار پیش‌فرض این صفت ``28`` است. بدیهی است برای اینکه اعداد در محدوده دقت کوچکتری نسبت به طول خود قرار بگیرند نیاز به گرد شدن دارند؛ برای تنطیم عمل گرد کردن در اعداد دسیمال نیز از صفت ``rounding`` که مقدار پیش‌فرض آن ``"ROUND_HALF_EVEN"`` است، استفاده می‌شود::

    >>> a = decimal.Decimal('2.0')
    >>> b = decimal.Decimal('0.52')

    >>> ctx.prec
    28
    >>> ctx.rounding
    'ROUND_HALF_EVEN'

    >>> print(a + b)
    2.52

    >>> ctx.prec = 2

    >>> print(a + b)
    2.5

    >>> ctx.rounding = "ROUND_CEILING"

    >>> print(a + b)
    2.6

صفت ``rounding`` می‌بایست حاوی مقادیر ثابتی به شرح پایین باشد:

* **ROUND_CEILING** - گرد کردن به سمت مثبت بی‌نهایت: یعنی برای اعداد **مثبت** ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52`` به ``2.6`` گرد می‌شود. برای اعداد منفی نیز تنها اعداد خارج از محدوده حذف می‌گردند مثلا عدد ``2.19-`` به ``2.1-`` گرد می‌شود.
* **ROUND_FLOOR** - گرد کردن به سمت منفی بی‌نهایت: یعنی برای اعداد **منفی** ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52-`` به ``2.6-`` گرد می‌شود. برای اعداد مثبت نیز تنها اعداد خارج از محدوده حذف می‌گردند مثلا عدد ``2.19`` به ``2.1`` گرد می‌شود.
* **ROUND_DOWN** - گرد کردن به سمت صفر: یعنی برای اعداد مثبت و منفی تنها ارقام خارج از محدوده حذف می‌گردند مثلا عدد ``2.58`` به ``2.5`` و عدد ``2.58-`` به ``2.5-`` گرد می‌شود.
* **ROUND_UP** - گرد کردن به دور از صفر: یعنی برای اعداد مثبت و منفی ارقام خارج از محدوده حذف می‌گردند و آخرین رقم باقی مانده یک واحد افزایش می‌یابد مثلا عدد ``2.52`` به ``2.6`` و عدد ``2.52-`` به ``2.6-`` گرد می‌شود.
* **ROUND_HALF_DOWN** - اگر رقم ابتدایی بخش حذف شده بزرگتر از ``5`` باشد به روش ROUND_UP و در غیر این صورت به روش ROUND_DOWN گرد می‌گردد. مثلا عدد ``2.58`` به ``2.6`` و عدد ``2.55`` به ``2.5`` گرد شده و همینطور عدد ``2.58-`` به ``2.6-`` و عدد ``2.55-`` به ``2.5-`` گرد می‌شود.
* **ROUND_HALF_UP** - اگر رقم ابتدایی بخش حذف شده بزرگتر یا برابر ``5`` باشد به روش ROUND_UP و در غیر این صورت به روش ROUND_DOWN گرد می‌گردد. مثلا عدد ``2.55`` به ``2.6`` و عدد ``2.51`` به ``2.5`` گرد شده - همینطور عدد ``2.55-`` به ``2.6-`` و عدد ``2.51-`` به ``2.5-`` گرد می‌کند.
* **ROUND_HALF_EVEN** - همانند ROUND_HALF_DOWN است ولی در مواقعی که رقم ابتدایی بخش حذف شده برابر ``5`` باشد رفتار آن متفاوت می‌شود: در این حالت اگر آخرین رقم باقی مانده زوج باشد به شیوه ROUND_DOWN و اگر فرد باشد به روش ROUND_UP گرد می‌گردد. مثلا عدد ``2.68`` به ``2.7``، ``2.65`` به ``2.6`` و ``2.75`` به ``2.8`` - همینطور عدد ``2.68-`` به ``2.7-``، ``2.65-`` به ``2.6-`` و ``2.75-`` به ``2.8-`` گرد می‌کند.
* **ROUND_05UP** - اگر بر اساس روش ROUND_DOWN آخرین رقم باقی مانده ``0`` یا ``5`` باشد؛ به روش ROUND_UP و در غیر این صورت به همان شیوه ROUND_DOWN گرد می‌کند. مثلا عدد ``2.58`` به ``2.6`` و ``2.48`` به ``2.4`` - همینطور عدد ``2.58-`` به ``2.6-`` و ``2.48-`` به ``2.4-`` گرد می‌شود.

ماژول ``decimal`` یا نوع دسیمال پایتون شامل جزییات و ویژگی‌های بسیار بیشتری است که برای آگاهی از آن‌ها می‌بایست صفحه مربوط به آن در `اسناد پایتون  <https://docs.python.org/3/library/decimal.html>`__ را مطالعه نمایید.


.. _python-fraction-numbers: 

کسر (Fraction)
------------------

این نوع برای پشتیبانی اعداد گویا (Rational) در پایتون ارایه شده است و با ایجاد شی از کلاس ``Fraction`` درون ماژول ``fractions`` در دسترس قرار می‌گیرد [`اسناد پایتون  <https://docs.python.org/3/library/fractions.html>`__]::


    >>> from fractions import Fraction

    >>> Fraction(1, 2)
    Fraction(1, 2)

    >>> float(_)
    0.5

::

    >>> import fractions

    >>> a = 1
    >>> b = 2
    >>> f = fractions.Fraction(a, b)

    >>> f
    Fraction(1, 2)

    >>> print(f)
    1/2

    >>> type(f)
    <class 'fractions.Fraction'>

    >>> import sys
    >>> sys.getsizeof(f)
    56

علاوه‌بر روش بالا که به صورت مستقیم صورت و مخرج کسر  - از نوع صحیح - مشخص شده است؛ به روش‌های دیگری نیز می‌توان یک شی کسری ایجاد نمود:

* از یک شی ممیز شناور - بهتر است این نوع به صورت رشته وارد شود::

    >>> print(Fraction('0.5'))
    1/2
    >>> print(Fraction('1.1'))
    11/10
    >>> print(Fraction('1.5'))
    3/2
    >>> print(Fraction('2.0'))
    2

  ::

      >>> print(Fraction(0.5))
      Fraction(1, 2)

      >>> print(Fraction(1.1))
      2476979795053773/2251799813685248
      >>> 2476979795053773 / 2251799813685248
      1.1

      >>> print(Fraction(1.5))
      3/2

  همچنین با استفاده از متد ``()limit_denominator`` [`اسناد پایتون  <https://docs.python.org/3/library/fractions.html#fractions.Fraction.limit_denominator>`__] و محدود کردن مخرج یک شی کسر به یک مقدار بیشینه (که از ورودی دریافت می‌کند) می‌توان به صورت تقریبی، معادل‌های کسری از اعداد ممیز شناور را به دست آورد::

      >>> Fraction(1.1).limit_denominator()
      Fraction(11, 10)

  ::

      >>> import math

      >>> math.pi
      3.141592653589793

      >>> pi = math.pi

      >>> Fraction(pi)
      Fraction(884279719003555, 281474976710656)
      >>> 884279719003555 / 281474976710656
      3.141592653589793

      >>> Fraction(pi).limit_denominator()
      Fraction(3126535, 995207)
      >>> 3126535 / 995207
      3.1415926535886505

      >>> Fraction(pi).limit_denominator(8)
      Fraction(22, 7)
      >>> 22 / 7
      3.142857142857143

      >>> Fraction(pi).limit_denominator(60)
      Fraction(179, 57)
      >>> 179 / 57
      3.1403508771929824



* از یک شی دسیمال::

    >>> print(Fraction(Decimal('1.1')))
    11/10

* از یک رشته کسری - صورت و مخرج کسر می‌بایست از نوع صحیح باشند::

    >>> print(Fraction('3/14'))
    3/14

* از یک شی کسر دیگر::

    >>> f1 = Fraction(1, 2)
    >>> f2 = Fraction(3, 5)

    >>> Fraction(f1)
    Fraction(1, 2)

    >>> Fraction(f1, f2)
    Fraction(5, 6)

با استفاده از دو صفت ``numerator`` و ``denominator`` می‌توان به ترتیب به صورت و مخرج شی کسر دسترسی یافت::

    >>> f = Fraction('1.5')
    >>> f.numerator
    3
    >>> f.denominator
    2

از این نوع شی به سادگی می توان در انواع محاسبات ریاضی استفاده کرد؛ برای نمونه به تکه کد پایین توجه نمایید::

    >>> Fraction(1, 2) + Fraction(3, 4)
    Fraction(5, 4)

    >>> Fraction(5, 16) - Fraction(1, 4)
    Fraction(1, 16)

    >>> Fraction(3, 5) * Fraction(1, 2)
    Fraction(3, 10)

    >>> Fraction(3, 16) / Fraction(1, 8)
    Fraction(3, 2)

چنانچه یک شی صحیح به شی کسر افزوده شود حاصل یک شی کسر است ولی اگر یک شی ممیز شناور به شی کسر افزوده شود حاصل یک شی از نوع ممیز شناور می‌باشد::

    >>> Fraction(5, 2) + 3
    Fraction(11, 2)

    >>> Fraction(5, 2) + 3.0
    5.5

.. rubric:: ب.م.م

ماژول ``fractions`` علاوه بر نوع کسری؛ حاوی تابع ``()gcd`` [`اسناد پایتون  <https://docs.python.org/3/library/fractions.html#fractions.gcd>`__] نیز است. این تابع «بزرگترین مقسوم‌علیه مشترک» (`GCD  <https://en.wikipedia.org/wiki/Greatest_common_divisor>`_) دو عدد را برمی‌گرداند::

    >>> import fractions
    >>> fractions.gcd(54, 24)
    6


.. _python-boolean: 

بولی (Boolean)
------------------

کلاسی که در پایتون از آن برای ایجاد شی بولی استفاده می‌شود (``bool``) در واقع یک کلاس فرزند از کلاس اعداد صحیح (``int``) است. این نوع شی تنها می‌تواند یکی از دو مقدار ``True`` (درست) یا ``False`` (نادرست) را داشته باشد که ``True`` برابر با عدد صحیح ``1`` و ``False`` برابر با عدد صحیح ``0`` ارزیابی می‌گردد::

    >>> a = True

    >>> a
    True

    >>> type(a)
    <class 'bool'>

    >>> import sys
    >>> sys.getsizeof(a)
    28


::

    >>> int(True)
    1

    >>> int(False)
    0

    >>> float(True)
    1.0

    >>> complex(True)
    (1+0j)


::

    >>> True + 1
    2

    >>> False + 1
    1

    >>> True * 25
    25

    >>> False * 25
    0

کلاس ``()bool`` یا متد ``()__bool__`` مقدار بولی یک شی را برمی‌گرداند [`اسناد پایتون  <https://docs.python.org/3/library/functions.html#bool>`__]::

    >>> bool(0)
    False

    >>> bool(1)
    True

    >>> bool("")   # Empty String
    False

::

    >>> a = 15
    >>> a.__bool__()
    True

    >>> a = -15
    >>> a.__bool__()
    True

    >>> a = 0
    >>> a.__bool__()
    False

در پایتون اشیا پایین به مقدار بولی ``False`` (نادرست) ارزیابی می‌گردند:

* ``None``
* ``False``
* شی صفر (در انواع گوناگون): ``0``، ``0.0``، ``0j``
* تمام اشیا دنباله‌ خالی: ``""``، ``()``، ``[]``
* شی دیکشنری خالی: ``{}``
* شی مجموعه خالی: ``()set``

*با موارد نا آشنا به مرور آشنا می‌شوید.*


|

----

:emoji-size:`😊` امیدوارم مفید بوده باشه


